
#written by Abhijit mohanta and chatgpt
#script lists the API's called and the string referened in a function. Also gives hints about the usage of API and string 

import os
from ghidra.program.model.listing import Function
from ghidra.program.model.symbol import RefType

# Hard-coded dictionaries for API functionality and string functionality
api_functionality = {

    #string API	
    "lstrcmpiW": "string comparision",
    "lstrcatW": "string concat",
    "lstrcmpiA": "string comparision",
    "lstrcatA": "string concat",
    "lstrlenA": "string length",
   "lstrlenW": "string length",
   "StrStrW": "check is string is substring",
   "StrStrA": "check is string is substring",
   "lstrcpyW":"string copy",
   "lstrcpyA":"string copy",

 
    "wsprintfW": "string formatting",
    "wsprintfA": "string formatting",
 
    #file system API
    "GetLogicalDrives": "Get list of drives",
    "GetDriveTypeW": "Get Drive Type",
    "FindFirstFileW":"file iteration",
    "CopyFileW":"copy file",	
    "CopyFileA":"copy file",	
    "CreateFileA": "Creates or opens a file.",
    "CreateFileW": "Creates or opens a file.",
    "WriteFileA": "Writes data to a file.",
    "WriteFileW": "Writes data to a file.",
    "SetFileAttributesW": "change attribute of a file",
   "SetFileAttributesA": "change attribute of a file",
    "SetFilePointer":"sets pointer in file before writing",
    "SHGetSpecialFolderPathW":"get path of special folder",
    "SHGetSpecialFolderPathA":"get path of special folder",


     #memory string API
     "LocalAlloc":"memory allocation",	 	
     "VirtualAlloc":"memory allocation",
      "WriteProcessMemory":"write to process meomory, if remote process then code injection",
     "HeapAlloc":"Memory allocation",
     "LocalFree":"memory free",
    #encryption API
    "CryptAcquireContextW": "Crypto API initialization",
    "CryptAcquireContextA": "Crypto API initialization",
    "CryptReleaseContext":"Crypto API use finiched",   
    "CryptDestroyHash": "Crypto API",
    "CryptGenKey":"generate random key: possible for ransomware",
    "CryptExportKey":"write key BLOB to a buffer so that it can be written to file",
     #others
    "GetLocalTime":"time API",
     "CloseHandle":"close HAandle",
    #memory module
    "GetModuleHandleA":"get handle to module",
    "GetModuleHandleW":"get handle to module",
   "GetModuleFileNameW":"get file corrosponding to a module",
   "GetModuleFileNameA":"get file corrosponding to a module",

  #registry API
 "RegOpenKeyExW":"open registry key",
 "RegOpenKeyExA":"open registry key",
 "RegDeleteValueW":"Delete registry value",
 "RegDeleteValueA":"Delete registry value",
 "RegCloseKey":"close registry key ",

  #network enumeration and lateral movement
 "WNetOpenEnumW": "used for network driver enumeration",
 "WNetOpenEnumA": "used for network driver enumeration",

}

string_functionality = {
    #antiVM
    "VBOX": "Indicates virtual machine detection. Anti-VM",

    #backup deletion Ransomware
     "bcdedit": "backup deletion in Ransomware"

    # Add more strings and their functionalities here
}

# Function to get all functions in the current program
def get_functions():
    function_manager = currentProgram.getFunctionManager()
    functions = function_manager.getFunctions(True)
    return functions

# Function to get instruction addresses and their corresponding API calls
def get_instruction_addresses_and_apis(func):
    listing = currentProgram.getListing()
    instructions = listing.getInstructions(func.getBody(), True)
    
    api_calls = []
    
    for instruction in instructions:
        for reference in instruction.getReferencesFrom():
            if reference.getReferenceType().isCall():
                target_function = getFunctionAt(reference.getToAddress())
                if target_function:
                    api_name = target_function.getName()
                    functionality = api_functionality.get(api_name, "Unknown")
                    api_calls.append((instruction.getAddress(), instruction, api_name, functionality))
                    
    return api_calls

# Function to get string references in a function
def get_strings_in_function(func):
    listing = currentProgram.getListing()
    instructions = listing.getInstructions(func.getBody(), True)
    
    string_references = []
    
    for instruction in instructions:
        for reference in instruction.getReferencesFrom():
            data = getDataAt(reference.getToAddress())
            if data and data.getDataType().getDisplayName().lower() in ["string", "unicode"]:
                string_value = str(data.getValue())
                functionality = "Unknown"
                for key, value in string_functionality.items():
                    if key in string_value:
                        functionality = value
                        break
                string_references.append((instruction.getAddress(), instruction, string_value, functionality))
    
    return string_references

# Main function to print API calls and string references for each function
def main():
    try:
        output_file = os.path.join(os.getenv('TEMP'), 'ghidra_output.txt')
        
        with open(output_file, 'w') as f:
            functions = get_functions()
            
            for func in functions:
                start_addr = func.getBody().getMinAddress()
                end_addr = func.getBody().getMaxAddress()
                
                f.write("\n\n**************************************\n")
                f.write("\nFunction: {} (Start: {}, End: {})\n".format(func.getName(), start_addr, end_addr))
                
                # Print API calls
                api_calls = get_instruction_addresses_and_apis(func)
                if api_calls:
                    f.write("API Calls:\n")
                    for addr, instr, api, functionality in api_calls:
                        f.write("  => {} - {}  => API called : {}, API Functionality: {}\n".format(addr, instr, api, functionality))
                else:
                    f.write("No API Calls found.\n")
                
                # Print string references
                string_refs = get_strings_in_function(func)
                if string_refs:
                    f.write("String References:\n")
                    for addr, instr, string, functionality in string_refs:
                        f.write("  => {} - {}  => String refered: {}, string used for: {}\n".format(addr, instr, string, functionality))
                else:
                    f.write("No String References found.\n")
        
        # Open the output file in Notepad
        os.system('notepad.exe "{}"'.format(output_file))
    
    except Exception as e:
        print("Error occurred:", e)

# Run the main function
main()
