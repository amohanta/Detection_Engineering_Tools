#place script in %Ghidra_Home%\Ghidra\Features\Base\ghidra_scripts
#Note: The output may have marny characters so change Ghidra console settings to 
#display more characters
from ghidra.program.util import DefinedDataIterator
from ghidra.app.util import XReferenceUtil

print "Ghidra Malware_Function_Reconer"
print "Dispalys the function and the API it calls and the string it uses \n"
print "By Abhijit Mohanta : abhijit.mohanta.15.08@gmail.com"

API_Mal_Dict={ "NetworkOp":["httpSendRequest","recv", "InternetCreateUrlA"],
				"FileOp":["CreateFileA","CreateFileW", "FindFirstFileA", "FindNextFileA","WriteFile"],
				"ProcessOp":["CreateProcess","OpenProcess","SetCurrentDirectoryA"],
				"RegistryOp" :[" RegCloseKey", "RegOpenKeyA","RegEnumKeyExA", "RegCloseKey"], 
				"StringOp":["lstrcmpiA","StrStrIA","lstrlenA","wsprintfA"]
			  }

def findAPIType(APIName):
	APItype =''
	for keyAPI,valueAPI in API_Mal_Dict.items():
		for value in valueAPI:
			if str(value) == APIName:
				return str(keyAPI)
	return	APItype
		
symbol = currentProgram.getSymbolTable()
dummy = 0
from ghidra.program.model.symbol import SymbolIterator
# Get the current program
program = getCurrentProgram()
# Get the symbol manager for the current program
symbol_manager = program.getSymbolTable()
fm = currentProgram.getFunctionManager()
APIDict={}
APIInfoFull = []
# Iterate through all symbols
for symbol in symbol_manager.getAllSymbols(True):
	if str(symbol).startswith("PTR_") :
		if( str(symbol).startswith("PTR_DAT_") or #symbol Not API
			str(symbol).startswith("PTR_FUN_") or#symbol Not API
			str(symbol).startswith("PTR_IMAGE_NT_HEADERS32")):#symbol Not API
			
			dummy = 0#print ("not interested")
		else:
			if str(symbol).startswith("PTR__") :#symbol starts with PTR__
				API_Name = ((str(symbol).split("__")[1]).split("_"))[0]				
			else:
				API_Name = str(symbol).split("_")[1]
				
			tempLst = []
			tempLst2 = []
			
			for reference in symbol.references:
				target_addr = "0x" + str(str(reference.fromAddress))
				referencesL2 = getReferencesTo(toAddr(target_addr))
				for ref in referencesL2:
					tempLst = []
					call_addr = ref.getFromAddress()
					func_name = fm.getFunctionContaining(call_addr)
					try:
						func_EP =func_name.getEntryPoint()
					except Exception, e:
						func_EP = "None" #func_name
						pass
					#print "func_EP =>" + str(func_EP)
					tempLst.extend([API_Name,"0x" + str(func_EP),"0x" + str(call_addr) ])
					tempLst2.append(tempLst)
				APIInfoFull.extend(tempLst2)
for info in APIInfoFull:
	if info[1] in APIDict.keys(): # if the function name(Functon_EP) in keys   
		temp=[]
		temp.extend([info[0],info[2]])  
		APIDict[info[1]].append(temp)
 
	if  info[1]!='None' and not(info[1] in APIDict.keys()) :
		APIDict[info[1]]=[]
		temp=[]
		temp.append([info[0],info[2]])
		APIDict[info[1]].extend(temp)

StringInfo=[]
for string in DefinedDataIterator.definedStrings(currentProgram):
	for ref in XReferenceUtil.getXRefList(string):
		address = currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(hex(int('0x'+str(ref),16)))
		func_name = fm.getFunctionContaining(address)
		try:
			func_EP =func_name.getEntryPoint()
		except Exception, e:
			func_EP = "None"#func_name
			pass
		

		temp=[]
		string = (str(string)).strip("ds \"")
		temp.extend([str(string),'0x'+str(ref),'0x'+str(func_EP)])
		StringInfo.append(temp)

StringDict={}

for info in StringInfo:
	if info[2] in StringDict.keys(): # if the function name in keys   
		temp=[]
		temp.extend([info[0],info[1]])  
		StringDict[info[2]].append(temp)
 
	if  info[2]!='None' and not(info[2] in StringDict.keys()) :
		StringDict[info[2]]=[]
		temp=[]
		temp.append([info[0],info[1]])
		StringDict[info[2]].extend(temp)
   
APIType = ""
StringType = ""
for key, value in APIDict.items():
	print("\n\n========================================================\n")
	print("function : " + str(key)+ "\n")
	print ("    API's called    :\n")
	APIType = ""
	for entry in value:
		APITypeTemp =""
		print("		" + str(entry[1]) + " -> " + str(entry[0])  )
		APITypeTemp = findAPIType(str(entry[0]))
		if APITypeTemp not in APIType:
			APIType = APIType+"," + str(APITypeTemp)
	print "\n"
	print ("    strings     :\n")
	for KeyStr, ValueStr in StringDict.items():
		if str(key) == str(KeyStr):
			StringTypeTemp = ""
			for EntryStr in ValueStr:
				print ("	        " + str(EntryStr[1])+ " -> " + str(EntryStr[0]) )
	print "\n\n    API Types in the function => " + str(APIType)
